<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Web Worker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/19/Web%20Worker/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T14:44:59.915Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/19/Web%20Worker/">Web Worker</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>面试的时候有被问到一个场景：一个页面渲染程的需要计算上亿的次的计算，如何可以将页面尽量快的完成渲染</p>
<ul>
<li>一开始以为是考<code>&lt;script&gt;</code>写的位置（body的底部），或者defer属性（先下载渲染后再加载），但是似乎都不是面试官想要的答案</li>
<li>直到学习到了Web Worker…</li>
</ul>
</li>
<li><p>Web Worker</p>
<ul>
<li><p>概述：由浏览器提供的web Api，主要是为了个js提供多线程的能力，另开一线程执行代码，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7">兼容性</a></p>
</li>
<li><p>执行过程：使用代码<code>new Worker(&#39;url&#39;)</code>去加载url的代码（网络），然后在另外的线程执行url的代码，主线程和worker线程通过Worker.postMessage发送数据和window.onmessage接收数据来进行交互</p>
</li>
<li><p>限制：同源政策，内容安全策略（指定）</p>
</li>
<li><p>使用：</p>
<ul>
<li>main.js</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js </span><br><span class="line">        if (window.Worker) &#123;</span><br><span class="line">            const ww &#x3D; new Worker(&#39;.&#x2F;worker.js&#39;);</span><br><span class="line">            let first &#x3D; document.querySelector(&#39;#first&#39;)</span><br><span class="line">                ww.postMessage(&#39;go&#39;)</span><br><span class="line">            &#x2F;&#x2F; first.onchange &#x3D; function (v) &#123;</span><br><span class="line">                &#x2F;&#x2F; console.log(v.target.value)</span><br><span class="line">                &#x2F;&#x2F; ww.postMessage(v.target.value)</span><br><span class="line">            &#x2F;&#x2F; &#125;</span><br><span class="line">            ww.onmessage &#x3D; function (e) &#123;</span><br><span class="line">                result &#x3D; e.data;</span><br><span class="line">                console.log(&#39;Message received from worker&#39;);</span><br><span class="line">                first.value &#x3D; result</span><br><span class="line">                ww.terminate();</span><br><span class="line">            &#125;</span><br><span class="line">            ww.onerror &#x3D; function(e)&#123;</span><br><span class="line">                console.log(&#39;get error %o&#39;,e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&#39;not support web worker&#39;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>worker.js</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; worker.js</span><br><span class="line">onmessage &#x3D; function (e) &#123;</span><br><span class="line">    console.log(&#39;Message received from main script&#39;);</span><br><span class="line">    const start &#x3D; new Date().getTime()</span><br><span class="line">    let sum &#x3D; 0</span><br><span class="line">    for(let i&#x3D;0;i&lt;10000000000;i++)&#123;</span><br><span class="line">        sum +&#x3D; i</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(new Date().getTime() - start)</span><br><span class="line">    console.log(&#39;Posting message back to main script&#39;);</span><br><span class="line">    postMessage(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用后关闭主线程<code>worker.terminate()</code>，或这worker内部<code>close()</code></li>
</ul>
</li>
</ul>
</li>
<li><p>JavaScript是单线程的同时在浏览器中和GUI渲染的线程互斥，前面开头的提到的场景中：</p>
<ul>
<li><p>如果停下渲染html去执行计算，那么进入页面就会空白一段时间等js加载完再出现页面ui</p>
</li>
<li><p>如果使用把script直接放到html的body标签的最后，页面ui会渲染出来先，但在渲染完成后到js计算完成之前，页面ui交互可能会报错（计算未完成）；因为计算时间长，所以是可能在这段时间用户进行ui交互（可以加个“加载中”动画缓解用户焦虑，类似请求完成前一直loading)</p>
<p><code>time = renderHtml + downloadJs + runJs</code></p>
</li>
<li><p>如果使用<code>&lt;script&gt;</code>的defer,可以先并行下载后执行，相对上一点只是节省了一下下载时间（几乎忽略不计）</p>
<p><code>time = max(renderHtml, downloadJs) + runJs</code></p>
</li>
<li><p>如果使用web worker，先直接加载使用worker的js代码，然后渲染html；因为是另开线程来执行，所以不阻塞html渲染，页面ui应该会马上出来；因为页面和js计算基本同时执行，所以如果计算较大，使用Web Worker是最快的；</p>
<p><code>time = max(renderHtml, downloadJs + runJs)</code></p>
</li>
<li><p>当然无论如何，计算量大总是会有问题，所以加个加载动画是最好的，让用户看到页面又屏蔽用户的操作。</p>
</li>
</ul>
</li>
</ul>
<p>随记：</p>
<ul>
<li>考虑到Web Worker</li>
</ul>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html">Web Worker 使用教程</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers">使用 Web Workers</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/19/Web%20Worker/" data-id="ckk44e4g50005xwuz0x9q5at3" data-title="Web Worker" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-node开发cli" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/19/node%E5%BC%80%E5%8F%91cli/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T14:43:06.701Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/19/node%E5%BC%80%E5%8F%91cli/">node开发cli</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>一个公司，大概率上，会定义很多开发规则，而且在开发习惯上也会有很多相似的地方。这样每个项目类似的目录结构和配置。每一次搭建新项目就需要重新写一遍，这即“重复性工作”。为了减少这些“重复性工作”，cli（command line interface）出现，少量的参数即可自动搭建出一个项目雏形。著名的CLI有vue-cli，create-react-app等</p>
</li>
<li><p>利用node的npm来实现一个cli非常简单而且使用也非常方便</p>
<ul>
<li><p>首先创建一个npm包，<code>npm init</code></p>
<p>当前目录下会出现package.json</p>
</li>
<li><p>在package.json下添加“bin”属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;idkhts-cli-demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;lll&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;hgg&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">    </span><br><span class="line">  &#x2F;&#x2F;添加bin</span><br><span class="line">  &quot;bin&quot;:&#123;</span><br><span class="line">      &quot;cli&quot;:&quot;.&#x2F;index.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json的bin是npm提供的一个把执行文件快速注册到PATH的便捷方式，npm在下载的时候就会把bin属性下的值——执行的文件，符号链接（软链）到</p>
<ul>
<li>并且添加到npm的PATH路径变量下——全局安装</li>
<li><code>./node_modules/.bin</code>——局部安装</li>
</ul>
<p>全局安装后，执行对应的命令，<code>cli</code>，命令行后会查询PATH然后找到对应的文件执行；</p>
<p>若是局部安装，直接执行命令<code>cli</code>会报错，因为在PATH路径变量中并没有存在对应的可执行文件或软链。这种情况只能自己复制或者使用<code>npm run</code>,在package.json文件的scripts属性加上自己的命令，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; package.json</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">    &#x2F;&#x2F;添加自定义命令</span><br><span class="line">    &quot;nrcli&quot;:&quot;cli&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;添加bin</span><br><span class="line">  &quot;bin&quot;:&#123;</span><br><span class="line">      &quot;cli&quot;:&quot;.&#x2F;index.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>局部安装会把bin的定义的key生成文件名，所以在scripts定义的命令内容也是写cli，因为npm run是自动去寻找<code>./node_modules/.bin</code>文件，所以执行<code>npm run nrcli</code>意为“执行文件./node_modules/.bin/cli”</p>
</li>
<li><p>接下来，定义入口文件。因为前面只是配置了命令执行什么文件，但是系统还不知道要怎么执行文件，这样如果不是可执行文件都会报错。配置用node.js执行，在入口文件的顶部加上：</p>
<p><code>index.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env node</span><br><span class="line">&#x2F;&#x2F; do something ...</span><br></pre></td></tr></table></figure>
<p>这样，当系统执行文件时，读取第一行就知道当前文件应该在node环境下执行。</p>
</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://idkhts.github.io/2020/12/19/npm%E5%8C%85%E5%8F%91%E5%B8%83/">推送到npm</a>：<code>npm publish</code></p>
</li>
<li><p>使用</p>
<ul>
<li>局部安装<ul>
<li>安装<code>npm i &lt;cli-name&gt; --save-dev</code></li>
<li>修改package.json的<code>script</code>属性: 添加<code>&quot;nr-cmd&quot;:&quot;cli-cmd&quot;</code></li>
<li>执行<code>npm run nr-cmd</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>全局安装:</p>
<ul>
<li>安装<code>npm i &lt;cli-name&gt; -g</code></li>
<li>执行命令<code>&lt;cli-name&gt;</code> 即可</li>
</ul>
<h4 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h4><ul>
<li><p>比较好用的开发命令行工具的包<a target="_blank" rel="noopener" href="https://github.com/tj/commander.js/">commdaner.js</a>，</p>
<ul>
<li>version可以这样定义<code>program.version(require(&quot;./package.json&quot;).version)</code>自动和package.json的version对应</li>
<li>没有定义的命令，自带提示“错误命令”；自带<code>-h | --help</code>命令支持</li>
<li>踩过的坑是，最后一定要执行一句<code>program.parse(process.argv)</code></li>
</ul>
</li>
<li><p>npm发布前想要在本地测试，可以使用命令<code>npm link</code></p>
<ul>
<li><p>在需要发布的npm包目录下，执行命令<code>npm link</code>，然后npm就会把当前包生成软链添加到npm的全局路径下，并且添加入口文件的软链放npm的PATH路径变量下。若是写的包有定义bin属性，<code>npm link</code>就可以直接执行命令了；</p>
</li>
<li><p>若不是cli类的，需要加载到某个具体项目使用的，可以再在需要使用的项目根目录，执行命令<code>npm link &lt;package-name&gt;</code>，加载到具体的目录上；</p>
<p>因为是软链，当在具体项目中<code>npm link &lt;packge-name&gt;</code>加载了某个本地npm包，然后在项目中修改node_module中依赖会直接修改本地npm包</p>
</li>
<li><p><code>npm link</code>的效果其实和<code>npm i -g</code>是一样的，只是前者来源是本地，后者是npm服务器；<code>npm link</code>生成的是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5">软链</a>，所以本地修改包的效果会直接同步（本来就是执行本地的文件）</p>
</li>
</ul>
</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903831994630158">用一次就会爱上的cli工具开发</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json#bin">package.json | npm Docs</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html">npm scripts使用指南</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/44003359">PATH环境变量</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/19/node%E5%BC%80%E5%8F%91cli/" data-id="ckk44e4g70009xwuze62j542m" data-title="node开发cli" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node/" rel="tag">node</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-npm包发布" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/19/npm%E5%8C%85%E5%8F%91%E5%B8%83/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T14:42:27.861Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/19/npm%E5%8C%85%E5%8F%91%E5%B8%83/">npm包发布</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>首先必须是npm包，所以第一步是npm初始化<code>npm init</code></p>
<p>当前目录会出现一个package.json</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;p_n_p_demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;lll&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;hgg&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>name指定 包名</p>
<p>version指定 版本</p>
<p>keyword指定 关键字，用户可以通过<code>npm search</code>搜索到</p>
<p>description指定 包描述</p>
<p>main指定 包的入口</p>
<p>license指定 使用的许可协议（开源，闭源）</p>
</li>
<li><p>接下来就可以直接发布到npm服务器上了</p>
<ul>
<li>首先确保自己在npm<a target="_blank" rel="noopener" href="https://www.npmjs.com/">官网</a>拥有了账号</li>
<li>然后确保本地已经使用/登录了npm账号，若没有进行过相关操作则需要执行<code>npm adduser</code>(或者这个命令别名<code>npm login</code>、<code>npm add-user</code>)。可以通过命令<code>npm whoami</code>查看</li>
<li>使用命令<code>npm pulish</code>发布到npm服务器上</li>
</ul>
</li>
</ul>
<p>使用随记</p>
<ul>
<li>发布需要确保version和上次不一样，不然会发布失败</li>
<li>pacage.json的name和version组合构成唯一npm包的标识，所以缺少name或者version字段都会发布失败</li>
<li>package.json的version应该能被<a target="_blank" rel="noopener" href="https://github.com/npm/node-semver">node-semver</a>解析，不然会发布失败</li>
<li>使用命令<code>npm unpublish &lt;packageName&gt; --force</code> 取消发布，删除在npm服务器上的npm包</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a target="_blank" rel="noopener" href="https://docs.npmjs.com/cli/v6/configuring-npm/package-json">https://docs.npmjs.com/cli/v6/configuring-npm/package-json</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/19/npm%E5%8C%85%E5%8F%91%E5%B8%83/" data-id="ckk44e4ga000bxwuzfnfvhy8g" data-title="npm包发布" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DNS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/19/DNS/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T14:41:54.419Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/19/DNS/">DNS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>DNS，Domain Name System，域名系统；主要是用来把域名转换成IP地址。</p>
<ul>
<li><p>为什么ip不可以直接是域名的字符串样子？</p>
<p>ip是固定的32位（IPv4）如果是IPv6就是固定的128位，是二进制计算机容易识别。域名是不定长的（虽然有最大程度255字节而且）字符串形式机器直接使用困难，需要翻译。</p>
</li>
<li><p>那直接用ip不就好了，</p>
<p>为什么要有域名？好记啊。。。ip地址的一大串01数字，对人类太不友好了。</p>
</li>
</ul>
</li>
<li><p>域名系统是一个树结构倒转，最顶部为根，然后子节点是顶级域名，顶级域名的子节点为二级域名以此类推。</p>
<ul>
<li><p>规定域名由多级<strong>标号</strong>和<strong>点</strong>组成，如<code>www.mydns.org</code>，这里的www/mydns/org都是标号。标号规定最长为63个字符，域名规定最长为255字符。</p>
</li>
<li><p>为什么选用树型结构？树型结构的分级能比较好的唯一标识一个域名，而且层次比较分明：同样以<code>www.mydns.org</code>为例。解析是右到左的，也即首先解析org，然后是mydns，最后是www，考虑全世界有很多组织，所以顶级域名org代表非营利组织，每个组织有自己的名字，所以mydns组织申请了org顶级域名下的mydns二级域名使用，但是mydns有自己的各个部门，比如web开发的，那么组织可以用自己的二级域名mydns划分一个三级域名www。这样如果有另外的公司也叫mydns，那么它可以注册到顶级域名com下，完整域名就是mydns.com和mydns组织的域名mydns.org不同，所以可以起到一定的重用，比较贴合域名原来的使用含义。</p>
<p>一般www次级域名都表示web网站，mail表示邮件等</p>
</li>
<li><p>上一点又提<code>组织可以用自己的二级域名mydns划分一个三级域名www</code>一个机构/组织/其他什么的如果申请到了一个域名（无论是顶级还二级还是三级）那么这个机构可以自己划分更次级的域名。这也是为什么申请域名后可以划分子域名的原因</p>
</li>
<li><p>第二点也提到了<code>解析是右到左的</code>，如果本机没有对应的dns缓存，首先解析的就是顶级域名，那么就要先去根域名服务器上请求顶级域名，如果离根域名服务器远或者根域名服务器接受请求多那么响应就会久，网速也就慢了。这也就是为什么根域名服务器很重要的原因（分布是很不均匀，这也是一个资源）。</p>
</li>
</ul>
</li>
<li><p>需要注意一点，有种域名服务器称<strong>本地域名服务器</strong>是不在上文提到的树结构里面的。每个dns请求都会先发到本地域名服务器上去，若本地域名服务器不能解析再从根域名服务器查起。</p>
<ul>
<li>为什么需要先经过一个本地域名服务器？因为这样周围的主机询问的dns有可能重复，而把周围所有主机的dns进行一个缓存可以一定程度上减少请求的时间。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/19/DNS/" data-id="ckk44e4fe0000xwuzdv69br5e" data-title="DNS" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-TCP和UDP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/19/TCP%E5%92%8CUDP/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T14:41:04.903Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/19/TCP%E5%92%8CUDP/">TCP与UDP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>TCP/UDP是传输层协议，主要是目标主机到目标主机的通信；</p>
</li>
<li><p>TCP是<strong>面向连接的、可靠的、基于字节流的传输</strong></p>
<ul>
<li><p>面向连接：两台计算机通讯需要建立一个通讯连接，建立过程就是“</p>
<p>三次握手</p>
<p>”：客户端发起连接请求，服务端确认连接，客户端确认服务端的应答，建立连接成功。结束关闭连接时利用“</p>
<p>四次挥手</p>
<p>”确保连接的中断。</p>
<ul>
<li>需要三次握手的原因：假设只有两次即可建立，当客户端发送第一次连接请求网络延迟，客户端认为第一次请求超时重发一次请求，第二次请求正常到达服务端，服务端确认后发送确认，客户端收到确认连接建立，开始发送数据；然而这时第一次请求连接到达了服务端，但是服务端无法知道这是客户端在第二次请求建立连接是之前发送的，然后服务端再次为这个请求发送确认同时开启连接，客户端收到确认建立连接后发送数据却用的是第二次连接，所以延迟建立的连接是无用的，这也就消耗浪费了网络资源；</li>
<li>四次挥手：由于TCP是全双工的，所以连接A-》B和B-》A都要断。<ul>
<li>客户端A端发起关闭连接请求【1】</li>
<li>服务端B端接收确认关闭A-》B的信息流向通道（B不再接受本连接的A的信息）发送确认关闭信息，同时B端也发起关闭连接给A端【2】</li>
<li>A端接收确认关闭B-》A信息流向通道（A不再接受本连接的B的信息）发送确认关闭信息。【1】</li>
<li>这里注意最后一次挥手，A向B发确认，这时候A不能马上断开连接，还需要等待2MSL，MSL是报文段的最大生成时间，因为B还没收到A发的确认是还可以发送信息给A的，可能在此期间B又发送了数据，所以为了安全起见，A收到了结束请求发送确认还需要等2MSL才能关闭连接</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>因为三次握手的建立连接过程确保了发送双方的发送和接收能力，同时TCP使用了流量控制和拥塞控制方法控制网络影响，所以TCP提供了可靠的传输</p>
<ul>
<li><p>流量控制：用的是<strong>滑动窗口</strong>，流量控制指的的两台计算机的流量控制。主要思路是连接上的两台计算机都维护了一个缓冲区，表示<strong>可接收数据量</strong>，缓存区就叫窗口，接收方需要把窗口大小发送给发送方，让其发送数据要小于这个值，这样接收方就不会因为处理速度问题接收不及所有的数据；滑动窗口指的就是发送方发送数据都是这个窗口大小的数据，可以看作窗口在发送数据不断移动，发送窗口内的数据。</p>
</li>
<li><p>拥塞控制：是指整个网络的流量控制，具有<strong>全局性</strong>的。主要思想是慢慢试探，遇到阈值减低速度（一半）然后再试探（死亡边缘疯狂试探……直到非死亡最大值）；发送窗口需要综合考虑网络允许发送的数据量和目的主机可接收数据量确定大小；实际的算法有四种：<strong>慢开始（slow-start）</strong>、<strong>拥塞避免（congestion advoidance）</strong>、<strong>快重传（fast retransmit）</strong>和<strong>快恢复（fast recovery）</strong></p>
<ul>
<li><p>拥塞窗口cwnd：是一个状态变量，由网络的拥塞程度决定了拥塞窗口的大小，发送窗口应该小于或等于拥塞窗口</p>
</li>
<li><p>慢开始：主机开始发送数据时，不知道网络的负荷情况，不能发送大量的数据进入网络，发送窗口都是从小逐渐增大的：cwnd=1，发送方发送1个报文段，接收返回方返回1个确认，发送方cwnd+1，发送方再发2个报文段，接收方返回2个确认，发送方每收到一个确认cwnd就增加1；这样每经过一个传输轮次，cwnd就会翻倍。</p>
<p>1=》2=》4=》8,这就是<strong>慢开始</strong>，</p>
</li>
<li><p>ssthresh：显然不能然cwnd无限增大，这时后需要设置一个慢开始门限，ssthresh状态变量，开始时设ssthresh = 16</p>
<ul>
<li>cwnd &lt; ssthresh时，使用慢开始算法</li>
<li>cwnd &gt; ssthresh时，使用拥塞避免算法</li>
<li>cwnd = ssthresh时，既可以是慢开始算法也可以是拥塞避免算法</li>
</ul>
</li>
<li><p>拥塞避免算法：思想是让cwnd缓慢的增大，即每经过一个<strong>往返时间RTT</strong>，cwnd增加1；在拥塞避免阶段遇到了超时时，判断发送了网络拥塞，此时设置ssthresh=cwnd/2，cwnd=1（初始化cwnd，减小ssthresh），然后再执行慢开始</p>
</li>
<li><p>快重传算法：接收方按序发送接收报文段，当发现某一个报文段缺失时（M1接收了，然后没有M2但有M3传到）立即发送确认（发送前一个的确认，M1），后面再来两个也都发送这个确认（M4、M5也到了，但是都是发送M2确认），此时接收方就会收到四个<strong>连续重复</strong>的确认（M1、M3、M4、M5发的M1确认），说明有报文缺失（M2），发送方就立即重传这个报文（M2）</p>
</li>
<li><p>快恢复算法：像上面，发生了连续重复的三个确认，说明只是个别的报文段发生丢失（并非是网络拥塞造成的超时），不启动慢开始算法，而是<strong>快恢复算法</strong>：ssthresh = cwnd/2 （没有cwnd=1）并开始拥塞避免算法</p>
</li>
</ul>
</li>
<li><p>基于字节流的传输：TCP中的数据就是一个流，没有明确的边界，也即，发送十次给客户端，因为没边界服务器不知道有几次数据在这里，所以可以一次就把这些数据读取了，也可分100次读取；而UDP的报文是直接加个首部直接发的，有边界，发送一次数据服务器就读一次数据</p>
</li>
</ul>
<p>UDP：UDP是<strong>无连接传输</strong>，所以UDP<strong>不提供可靠传输</strong>也不需要建立连接，同时UDP是<strong>面向报文的</strong>，即对应用层的报文它只是加个UDP首部就交给IP层了，相对来说，TCP的消耗是更大的。总的来说它简单快捷，但是不可靠，功能单一。额外：UDP支持单播、多播、广播</p>
<ul>
<li>主要可以用到电话会议这种实时性比较高的场景</li>
</ul>
</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903958624878606#heading-9">面试官，不要问我三次握手和四次挥手</a></p>
<p>计算机网络（第七版）——谢希仁</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/19/TCP%E5%92%8CUDP/" data-id="ckk44e4g20003xwuzdx4nhx02" data-title="TCP与UDP" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-五层协议" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/19/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T14:40:10.729Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/19/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE/">五层协议</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>OSI七层协议概念清楚、概念完整但是过于复杂且不实用；TCP/IP协议在OSI协议完全出来时已经占领了市场，所以现在互联网都是基于使用TCP/IP协议；</p>
</li>
<li><p>OSI七层协议：应用层=》表示层=》会话层=》运输层=》网络层=》数据链路层=》物理层</p>
<p>TCP/IP协议：应用层=》运输层=》网际层=》网络接口层</p>
<p>因为TCP的最底层网络接口层实际没什么内容，所以教学一般使用结合OSI和TCP/IP优点的<strong>五层协议</strong></p>
<p>五层协议：应用层=》运输层=》网络层数据链路层=》物理层</p>
<p><a target="_blank" rel="noopener" href="https://idkhts.github.io/1606405644213.png"><img src="https://idkhts.github.io/1606405644213.png" alt="1606405644213"></a>1606405644213</p>
</li>
<li><p>五层协议的</p>
<ul>
<li><p>应用层：工作在<strong>具体应用进程之间</strong>的协议，通讯规则。比如HTTP协议，就是客户端（一台主机）浏览器（应用进程）和服务器（另一台主机）的应用服务（应用进程）的通讯协议。</p>
<p>主要协议有：HTTP，DNS，SMTP和POP3、IMAP（邮件），DHCP（动态主机配置）</p>
</li>
<li><p>运输层：工作<strong>一台主机的应用进程到另一台主机的应用进程</strong>之间，提供进程间的逻辑通道。比如TCP协议，规定主机间的通讯建立和断开，接收数据速度。</p>
<p>主要协议有：TCP/UDP，</p>
</li>
<li><p>主要协议：网际协议IP、配套IP协议的ARP、ICMP、IGMP</p>
<p>ARP，Address Resolution Protocal，主要是根据IP得出对应的物理地址（MAC地址）</p>
</li>
<li><p>数据链路层</p>
</li>
<li><p>物理层</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/19/%E4%BA%94%E5%B1%82%E5%8D%8F%E8%AE%AE/" data-id="ckk44e4gh000hxwuz50tw6678" data-title="五层协议" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-vue随记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/19/vue%E9%9A%8F%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T14:39:07.984Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/19/vue%E9%9A%8F%E8%AE%B0/">vue随记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>vue中组件必须且只能是由一个标签裹起来的，template同理</p>
</li>
<li><p>vue中使用<code>v-bind:attr=&quot;value&quot;</code>绑定属性，新版本中可以使用缩写<code>:attr=&quot;value&quot;</code><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/syntax.html#%E7%BC%A9%E5%86%99">,官方文档</a>：</p>
<p>v- 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，v- 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的单页面应用程序 (SPA - single page application) 时，v- 前缀也变得没那么重要了。因此，Vue 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写：</p>
</li>
<li><p><code>v-bind=&quot;obj&quot;</code>可以直接绑定一个对象，对象属性名为attr，值为attr绑定的值</p>
</li>
<li><p>v-once，标签内，仅绑定一次变量</p>
</li>
<li><p>使用v-html插入html标签，可以简单地防xss攻击</p>
</li>
<li><p>计算属性会缓存，只有依赖变更才会触发</p>
</li>
<li><p><code>v-bind:style=”&#123;...&#125;“</code>会自动添加浏览器引擎前缀</p>
</li>
<li><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。要想不复用看页使用key标识两个元素不能复用，<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/conditional.html#%E7%94%A8-key-%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%85%83%E7%B4%A0">用 <code>key</code> 管理可复用的元素</a></p>
</li>
<li><p>事件处理可以获取原生DOM事件对象，使用$event，<code>&lt;div @click=&quot;onClick(params,$event)&quot;&gt;&lt;/div&gt;</code></p>
</li>
<li><p>v-model其实是一个语法糖，v-bind和v-on的结合，并非真正的双向绑定</p>
</li>
<li><p>组件自定义事件名无所谓大驼峰/小驼峰，vue模板语法会全部转成小写，所以推荐kebab-case命名，即<code>handle-click</code>形式</p>
</li>
<li><p>组件名称为kabab-case命名只能用<code>&lt;my-component /&gt;</code>应用，用驼峰命名则可以用<code>&lt;my-component /&gt;</code>或<code>&lt;MyComponent /&gt;</code></p>
</li>
<li><p>vue的是单向数据流，prop是一个体现，父组件通过子组件定义prop可以传递数据到子组件，子组件修改这些数据不会影响父组件;这一点需要注意，对象这些引用类型</p>
</li>
<li><p>vue的prop的数据是单向的，如果想实现”双向“，vue2.3后提供了修饰符<code>.sync</code>，也是一个语法糖，实现””双向””绑定，这个修饰符只能绑定一些值类型，不能绑定对象等（过于复杂）</p>
</li>
<li><p><code>inheritAttrs</code>属性，标记是否继承attr，<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-props.html#%E9%9D%9E-Prop-%E7%9A%84-Attribute">非 Prop 的 Attribute</a></p>
</li>
<li><p>vue不能对对象/数组的变化指的是</p>
<ul>
<li>对于对象<ul>
<li>无法检测对象property的添加或移除，在vue的created后再添加property是不会别响应的</li>
<li>想要在created后添加又要响应<ul>
<li>可以应Vue.set(object,propertyName,value)或者其别名this.$set(…)</li>
</ul>
</li>
</ul>
</li>
<li>对于数组<ul>
<li>无法检测元素的值改变或者数组length的变化</li>
<li>想要在created后改元素值或者length又要响应<ul>
<li>同样可以使用Vue.set(arr,index,value)或this.$set(…)</li>
<li>使用vue封装过的数组方法（全部是更改原数组的方法，filter/map这些返回新数组不起作用）<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/19/vue%E9%9A%8F%E8%AE%B0/" data-id="ckk44e4ge000fxwuzf6q690qe" data-title="vue随记" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-vue-cli的vue.config.js" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/19/vue-cli%E7%9A%84vue.config.js/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T14:37:44.554Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/19/vue-cli%E7%9A%84vue.config.js/">vue-cli的vue.config.js</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li><p>vue-cli管理vue项目，一些配置写在vue.config.js下。vue-cli内置了webpack作为打包工具，这些配置也是写在vue.config.js了。</p>
</li>
<li><p>一些简单配置。。。看官方文档吧</p>
</li>
<li><p>使用webpack的optimization.splitChunks.cacheGroups来指定打包拆分规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F;configureWebpack是vue-cli3后自己维护的，最终通过webpackMerge合并到webpack配置对象</span><br><span class="line">    configureWebpack: config &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;** cacheGroups的子属性是一个对象，这个对象的属性指定具体的打包规则</span><br><span class="line">         *  name：指定打包后文件的名称，具体打包后还会加上一个hash</span><br><span class="line">         *  test：匹配规则</span><br><span class="line">         *  chunks：指定哪些文件可以应用这个规则优化，值域：&#39;all&#39;、&#39;initial&#39;、&#39;async&#39;，all为所有模块都应用这个规则，initial为初始化模块才应用这个规则，即第一次加载时就需要用到文件，&#39;async&#39;异步，即按需加载的模块</span><br><span class="line">         * 【这样调用config.optimization.splitChunks(&#123;cacheGroups:&#123;common:&#123;name:...&#125;&#125;&#125;)</span><br><span class="line">         * 但是遇到TypeError:config.optimization.splitChunks is not a function报错</span><br><span class="line">         * 所以写成以下这样，事实上config.optimization.splitChunks就是一个对象而已的子属性</span><br><span class="line">         * 而已，所以肯定不可以把splitChunks对象当函数来用】</span><br><span class="line">         *&#x2F;</span><br><span class="line">        config.optimization.splitChunks.cacheGroups.common &#x3D; &#123;</span><br><span class="line">            name: &#39;echarts&#39;,</span><br><span class="line">            test: &#x2F;[\\&#x2F;]node_modules[\\&#x2F;]?echarts[\\&#x2F;]?&#x2F;, &#x2F;&#x2F; can customize your rules</span><br><span class="line">            minChunks: 1, &#x2F;&#x2F;  minimum common number</span><br><span class="line">            priority:5,</span><br><span class="line">            reuseExistingChunk: true,</span><br><span class="line">            minSize:1,</span><br><span class="line">            chunks:&#39;all&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F;vue.config.js中还可以使用webpack-chain这个库（github上）来配置webpack</span><br><span class="line">    chainWebpack: config &#x3D;&gt; &#123;</span><br><span class="line">        config.optimization.splitChunks(&#123;</span><br><span class="line">            vendors:&#123;</span><br><span class="line">                name&#39;chunk-vendors&#39;,</span><br><span class="line">                test:&#x2F;[\\&#x2F;]node_module[\\&#x2F;]&#x2F;,</span><br><span class="line">                priority: -5,</span><br><span class="line">            	chunks:&#39;all&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            commons:&#123;</span><br><span class="line">                ....</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>拆分完包，似乎还未能完成；多页面应用中，拆出来的chunk，html要怎么知道哪些chunk它需要用？</p>
<ul>
<li>答案是使用webpack的htmlwebpackplugin</li>
</ul>
</li>
<li><p>额外的，可以使用<code>npx vue-cli-service inspect</code>查看本配置文件最终得到的webpack配置，可直接写到一个文件里面查看<code>npx vue-cli-service inspect &gt; config.js</code></p>
</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a target="_blank" rel="noopener" href="https://cli.vuejs.org/zh/guide/webpack.html">简单的配置方式</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903680307625997">webpack SplitChunksPlugin实用指南</a></p>
<p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/split-chunks-plugin/#splitchunkschunks">webpack optimization.splitchunks</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ahwgs.cn/vue-cli3-build.html#2splitChunks">基于Vue-cli3一些常见的优化</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/19/vue-cli%E7%9A%84vue.config.js/" data-id="ckk44e4gb000dxwuz3hte7atr" data-title="vue-cli的vue.config.js" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue组件的Api组件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/19/Vue%E7%BB%84%E4%BB%B6%E7%9A%84Api%E7%BB%84%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T14:36:06.462Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/19/Vue%E7%BB%84%E4%BB%B6%E7%9A%84Api%E7%BB%84%E4%BB%B6/">Vue组件的Api组件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p> 在使用vue框架时，正常的组件调用都是直接使用模板或使用选择器渲染，但在项目中有遇到，直接在js中用api弹出对话框的业务（公共逻辑的一个js文件夹中，代码使用了一个其它库，js直接弹出对话框）；使用了vue框架，为了弹窗不必再引入其他库，就需要了解到vue组件的api式调用。</p>
<ul>
<li><p>api式调用，指的就是可以在一段js代码中，直接渲染组件，比如这里的例子弹窗</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;xxx.js</span><br><span class="line">funciton doSomething()&#123;</span><br><span class="line">    dialog.open(params); &#x2F;&#x2F;页面直接弹出对话框进行交互</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;类似layer库的，layer.open(...)</span><br></pre></td></tr></table></figure></li>
<li><p>实现</p>
<ul>
<li><p>首先，vue组件的生命周期顺序是：created–》mounted，然后页面就会渲染组件。可以知道正常的vue组件渲染是，生成vue组件对象然后mounted挂载；那么我们需要的是js调用时才渲染也即才挂载，那么想要实现编程式调用，那么就要延后挂载，由我们决定什么时候再挂载</p>
</li>
<li><p>类似vue普通组件的，我们得先构建好vue对象。但只有在需要被调用时才进行挂载；那么如何构建vue对象呢？</p>
</li>
<li><p>利用Vue.extend()构建一个带挂载的vue对象，这里扩展了Vue类（Vue构造函数）；理解extend，先理解两点：</p>
<ol>
<li>返回的是一个构造函数（constructor）而不是一个对象，想要这种类型的对象还需要用<code>new</code>操作符；</li>
<li>Vue.extend()接收一个参数，是一个组件的选项对象，extend做的操作大概就是像new Vue()一样——把这个组件的选项对象的初始化构造一个vue对象。但是和new构造不同点是extend返回的是一个经过这样初始化的<strong>构造函数</strong>而不是对象。也即，由这个构造函数构造的对象是肯定会经过之前那个组件的选项对象初始化的vue对象，有点类似延迟函数的方式，先进行了一层初始化。是Vue对象的一个“子类”。</li>
</ol>
<ul>
<li>2中这样有什么用？如同extend这个词的原来意思，扩展，Vue.extend得到的构造函数构造的对象无疑是vue对象，但是这个对象比原生的vue多初始化了一些东西，也即扩展了也些东西。除此之外，返回了一个构造函数，意味着这个是独立于原生Vue构造函数的，对原生Vue没有任何影响（这一点是和mixin的本质区别，mixin就是影响原生Vue的）</li>
<li>再理解官方概括：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</li>
</ul>
</li>
<li><p>得到构造函数后，使用new操作符即可构造vue组件对象，这时再暴露一个封装了使用vm.$mount()的函数，让使用者调用这个函数触发渲染组件即可完成编程式的调用</p>
</li>
<li><p>例子：一个对话框（样式很丑。。)</p>
</li>
</ul>
<p><code>dialog.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">&#x2F;&#x2F;import &#39;.&#x2F;dialog.css&#39;</span><br><span class="line"></span><br><span class="line">export let  Dialog &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1.使用Vue.extend()构建一个Vue组件的构造函数</span><br><span class="line">const ApiComponent &#x3D; Vue.extend(&#123;</span><br><span class="line">    name: &#39;apiComponent&#39;,</span><br><span class="line">    render: function (h) &#123;</span><br><span class="line">        console.log(h)</span><br><span class="line">        return (</span><br><span class="line">            &lt;div class&#x3D;&quot;cover&quot; onclick&#x3D;&#123;this.onClose&#125;&gt;</span><br><span class="line">                &lt;div class&#x3D;&quot;dialog&quot; &gt;</span><br><span class="line">                    &#123;this.msg&#125;</span><br><span class="line">                    &lt;button class&#x3D;&quot;btn&quot; onclick&#x3D;&#123;this.onClose&#125;&gt;确定&lt;&#x2F;button&gt;</span><br><span class="line">                &lt;&#x2F;div&gt;</span><br><span class="line">                </span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    data: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg: &#39;i a api component&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        document.querySelector(&#39;.dialog&#39;).addEventListener(&#39;click&#39;,(e)&#x3D;&gt;e.stopPropagation(),false)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        setMsg: function (params) &#123;</span><br><span class="line">            this.msg &#x3D; params</span><br><span class="line">        &#125;,</span><br><span class="line">        onClose:function () &#123;</span><br><span class="line">            &#x2F;&#x2F; 触发销毁</span><br><span class="line">            this.$destroy()</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed()&#123;</span><br><span class="line">        &#x2F;&#x2F;销毁</span><br><span class="line">        this.$cancel(this.$el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.封装打开对话框方法（使用vm.$mount())</span><br><span class="line">Dialog.open &#x3D; function ()&#123;</span><br><span class="line">    &#x2F;&#x2F;创建挂载点</span><br><span class="line">    const ref &#x3D; document.createElement(&#39;div&#39;)</span><br><span class="line">    document.body.appendChild(ref)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;构造vue对象，因为Vue.extend()返回的是一个Vue构造函数的“子类”</span><br><span class="line">    &#x2F;&#x2F;也具有Vue构造函数函数的功能，所以也是能接收一个vue组件的选项对象</span><br><span class="line">    &#x2F;&#x2F;构造时如果当前的与Vue.extend()的某些属性重复，优先使用当前的</span><br><span class="line">    let api &#x3D; new ApiComponent(&#123;</span><br><span class="line">        data:function()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                msg:&#39;haha&#39;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;调用$mount挂载</span><br><span class="line">    api.$mount(ref)</span><br><span class="line">    return api.$el</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3.这里封装一个销毁&#x2F;关闭方法</span><br><span class="line">const close &#x3D; (ref)&#x3D;&gt;&#123;</span><br><span class="line">    ref &amp;&amp; ref.remove()</span><br><span class="line">&#125; </span><br><span class="line">ApiComponent.prototype.$cancel &#x3D; close</span><br></pre></td></tr></table></figure>
<p><code>DemoComponent.Vue</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;demo-dialog&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;button @click&#x3D;&quot;onOpen&quot;&gt;open&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;Dialog&#125;  from &#39;.&#x2F;dialog.js&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name:&#39;demo-dialog&#39;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        onOpen:function()&#123;</span><br><span class="line">            &#x2F;&#x2F;直接调用，页面应该会直接弹窗</span><br><span class="line">            Dialog.open()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">&#x2F;*这里的样式应该直接导入到dialog.js*&#x2F;</span><br><span class="line">.dialog &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 20%;</span><br><span class="line">    width: 50%;</span><br><span class="line">    height: 50%;</span><br><span class="line">    margin: 0 25%;</span><br><span class="line">    background-color: white;</span><br><span class="line">&#125;</span><br><span class="line">.btn &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    width: 5rem;</span><br><span class="line">    height: 2rem;</span><br><span class="line">    margin: 1rem;</span><br><span class="line">    background-color: white;</span><br><span class="line">&#125;</span><br><span class="line">.cover &#123;</span><br><span class="line">    position: fixed;</span><br><span class="line">    top: 0;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    background-color: rgba(128, 128, 128, 0.315);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#Vue-extend">Vue-extend</a></p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#Vue-mixin">Vue-mixin</a></p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-destroy">vm-destroy</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/19/Vue%E7%BB%84%E4%BB%B6%E7%9A%84Api%E7%BB%84%E4%BB%B6/" data-id="ckk44e4g40004xwuz0uejccqq" data-title="Vue组件的Api组件" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SSO" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/19/SSO/" class="article-date">
  <time class="dt-published" datetime="2021-01-19T14:31:57.129Z" itemprop="datePublished">2021-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/19/SSO/">SSO</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h3><p> SSO，即Single Sign On单点登录，是一个多系统页面用户验证解决方案。过去web应用比较简单，应用可以建立在一个系统中，使用http+cookie等即可以实现，登录验证等功能；但现代的web应用越来越大，一个应用可能由多个子系统组成，多系统应用中单单使用cookie已经不能实现验证功能了（域名不同等原因），除非每进一个子系统都登录一次。。。SSO出现解决这个问题。</p>
<h4 id="SSO的原理大概是如下"><a href="#SSO的原理大概是如下" class="headerlink" title="SSO的原理大概是如下"></a>SSO的原理大概是如下</h4><ul>
<li><p>登录</p>
<ul>
<li>用户从子系统1进入，前端向后端请求数据。</li>
<li>后端发现没有认证（没令牌）,即未登录，让前端重定向。</li>
<li>前端收到响应，携带当前的地址（登录以后需要知道怎么跳转回来）跳转到登录页面【认证中心】。</li>
<li>用户输入账号密码，登录，前端向后端发送用户信息验证。</li>
<li>后端生成令牌（随机字符串，怎么生成自定义），存储在session中（redis），并向前端返回登录成功信息（cookie携带了令牌）。</li>
<li>登录页面前端根据第一步获取的地址再跳转回到之前页面。</li>
<li></li>
</ul>
</li>
<li><p>注销</p>
<ul>
<li>用户在子系统选择注销，前端发送请求给后端</li>
<li>后端清除对应session里的令牌，返回注销成功响应</li>
</ul>
</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dw3306/p/11143199.html"><strong>sso单点登录原理详解</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904154037649415">编程概念精讲(二)：单点登录(SSO)详解</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/19/SSO/" data-id="ckk44e4fy0001xwuzdnjk73s1" data-title="SSO" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/vue/" style="font-size: 20px;">vue</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 15px;">其他</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 10px;">浏览器</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 20px;">计算机网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/19/Web%20Worker/">Web Worker</a>
          </li>
        
          <li>
            <a href="/2021/01/19/node%E5%BC%80%E5%8F%91cli/">node开发cli</a>
          </li>
        
          <li>
            <a href="/2021/01/19/npm%E5%8C%85%E5%8F%91%E5%B8%83/">npm包发布</a>
          </li>
        
          <li>
            <a href="/2021/01/19/DNS/">DNS</a>
          </li>
        
          <li>
            <a href="/2021/01/19/TCP%E5%92%8CUDP/">TCP与UDP</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>